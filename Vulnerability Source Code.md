_N.B. The code shown below is taken from Spring Framework version 5.3.2_

The chain of execution until the source of vulnerability is as follows.
```java
ServletRequestDataBinder.doBind(MutablePropertyValues mpvs)                         // implemented in DataBinder
ServletRequestDataBinder.applyPropertyValues(MutablePropertyValues mpvs)            // implemented in DataBinder
PropertyAccessor.setPropertyValue(String propertyName, @Nullable Object value)      // implemented in AbstractNestablePropertyAccessor
PropertyAccessor.setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv)     // implemented in AbstractNestablePropertyAccessor
PropertyAccessor.processKeyedProperty(PropertyTokenHolder tokens, PropertyValue pv) // implemented in AbstractNestablePropertyAccessor
PropertyAccessor.getLocalPropertyHandler(String propertyName)                       // implemented in BeanWrapperImpl
CachedIntrospectionResults.getPropertyDescriptor(String propertyName)               // implemented in CachedIntrospectionResults
```

The vulnerability resides in the data binding performed by the `ServletRequestDataBinder` class
The class hierarchy is as follows: `ServletRequestDataBinder` > `WebDataBinder` > `DataBinder`

> `DataBinder.java [744-748]`
```java
protected void doBind(MutablePropertyValues mpvs) {
	checkAllowedFields(mpvs);
	checkRequiredFields(mpvs);
	applyPropertyValues(mpvs);
}
```
The previous method calls `applyPropertyValues`.

> `DataBinder.java [848-859]`
```java
protected void applyPropertyValues(MutablePropertyValues mpvs) {
	try {
		// Bind request parameters onto target object.
		getPropertyAccessor().setPropertyValues(mpvs,
			isIgnoreUnknownFields(),
			isIgnoreInvalidFields()
		);
	}
    catch (PropertyBatchUpdateException ex) {
		// Use bind error processor to create FieldErrors.
		for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {
			getBindingErrorProcessor().processPropertyAccessException(pae,
				getInternalBindingResult()
			);
		}
	}
}
```

The `ServletRequestDataBinder` attempts to bind the properties through the property accessor. Which is an instance of the class `BeanWrapperImpl` that inherits `AbstractNestablePropertyAccessor`.

> `AbstractNestablePropertyAccessor.java [235-247]`
```java
@Override
public void setPropertyValue(String propertyName, @Nullable Object value)
	throws BeansException
{
	
	AbstractNestablePropertyAccessor nestedPa;
	try {
		nestedPa = getPropertyAccessorForPropertyPath(propertyName);
	}
	catch (NotReadablePropertyException ex) {
		throw new NotWritablePropertyException(
			getRootClass(), this.nestedPath + propertyName,
			"Nested property in path '" + propertyName + "' does not exist", ex
		);
	}

	PropertyTokenHolder tokens = getPropertyNameTokens(
		getFinalPath(nestedPa, propertyName)
	);

	nestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));
}
```

As shown above, the function then sets the value through another _overloaded_ method, which then uses `processKeyedProperty` to alter the value of the object.

> `AbstractNestablePropertyAccessor.java [273-280]`
```java
protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {
	if (tokens.keys != null) {
		processKeyedProperty(tokens, pv);
	}
	else {
		processLocalProperty(tokens, pv);
	}
}
```

> `AbstractNestablePropertyAccessor.java [283-285]`
```java
private void processKeyedProperty(PropertyTokenHolder tokens, PropertyValue pv) {
	Object propValue = getPropertyHoldingValue(tokens);
	PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);
```

The `getLocalPropertyHandler` method implemented in the `BeanWrapperImpl` class uses `CachedIntrospectionResults` to retrieve accessible property descriptors. 

> `BeanWrapperImpl.java [227-232]`
```java
@Override
@Nullable
protected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {
	PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);
	return (pd != null ? new BeanPropertyHandler(pd) : null);
}
```

The `CachedIntrospectionResults` class is used by the Spring Framework to analyze and precache the `beanClass` properties. It filters, in the process, the `classLoader` and `protectionDomain` because of an earlier disclosed vulnerability.

> `CachedIntrospectionResults.java [286-306]`
```java
// This call is slow so we do it once.
PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();
for (PropertyDescriptor pd : pds) {
	if (Class.class == beanClass &&
			("classLoader".equals(pd.getName()) ||   
			 "protectionDomain".equals(pd.getName()))) {
		// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody  
		// needs to bind to those
		continue;
	}
	
	// ...
	
	pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);
	this.propertyDescriptors.put(pd.getName(), pd);
	Method readMethod = pd.getReadMethod();
	if (readMethod != null) {
		readMethodNames.add(readMethod.getName());
	}
}
```
